import { _ as _objectWithoutProperties, C as CustomShaderMaterial$1, a as _objectSpread2 } from './vanilla-c76442e0.esm.js';
import * as React from 'react';
import '@react-three/fiber';
import 'object-hash';
import 'three';
import 'glsl-tokenizer';
import 'glsl-token-string';
import 'glsl-token-functions';

function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}

var _excluded = ["baseMaterial", "fragmentShader", "vertexShader", "uniforms", "cacheKey"];
var CustomShaderMaterial = /*#__PURE__*/React.forwardRef(function (_ref, ref) {
  var baseMaterial = _ref.baseMaterial,
    fragmentShader = _ref.fragmentShader,
    vertexShader = _ref.vertexShader,
    uniforms = _ref.uniforms,
    cacheKey = _ref.cacheKey,
    props = _objectWithoutProperties(_ref, _excluded);
  var updateProps = React.useMemo(function () {
    return {
      fragmentShader: fragmentShader,
      vertexShader: vertexShader,
      uniforms: uniforms,
      cacheKey: cacheKey
    };
  }, [fragmentShader, vertexShader, uniforms, cacheKey]);
  var material = React.useMemo(function () {
    return new CustomShaderMaterial$1(_objectSpread2(_objectSpread2({
      baseMaterial: baseMaterial
    }, updateProps), props));
  }, [baseMaterial, updateProps]);
  React.useEffect(function () {
    return function () {
      return material.dispose();
    };
  }, [material]);

  // TODO: Use .update when it stop leaking memory
  // useDidUpdateEffect(
  //   () => material.update(updateProps),
  //   [updateProps]
  // )

  return /*#__PURE__*/React.createElement("primitive", _extends({
    attach: "material",
    object: material,
    ref: ref
  }, props));
});

export { CustomShaderMaterial as default };
